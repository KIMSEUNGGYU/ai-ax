# Level 1: 전체 그림

## Claude Code의 기본 동작

```
사용자 → [Claude Code (단일 에이전트)] → 결과
```

Claude Code는 기본적으로 **하나의 에이전트**가 순차적으로 작업한다.
파일 읽고 → 생각하고 → 코드 쓰고 → 테스트하고...

---

## Task 도구란?

Claude Code에 **내장된 도구**. 새로운 Claude 인스턴스(서브 에이전트)를 생성한다.

```
메인 Claude ──Task 호출──→ [새로운 Claude 인스턴스 생성]
                                ↓
                            독립된 컨텍스트에서 작업
                                ↓
                            결과만 메인에게 반환
```

**핵심: Task = 새로운 Claude를 하나 더 띄우는 것.** 메인 Claude와 별도의 대화창이 열린다고 생각하면 된다.

### 기본 사용 예시

```
// Claude Code 내장 에이전트 사용
Task(
  subagent_type = "Explore",
  prompt = "src/에서 로그인 관련 파일 찾아줘"
)

// 플러그인 에이전트 사용 (내가 만든 에이전트)
Task(
  subagent_type = "plugin:fe-workflow:architect",
  prompt = "로그인 페이지 설계해줘"
)
```

### Task의 특징

- 각 서브 에이전트는 **독립된 컨텍스트**에서 실행 (서로의 작업 내용 모름)
- 하나의 메시지에서 **여러 Task를 동시 호출** 가능 (병렬)
- 결과는 메인 Claude에게만 반환

---

## 멀티 에이전트 오케스트레이션

Task 도구를 활용해서 여러 전문 에이전트에게 작업을 분배하는 구조.

```
사용자 → [오케스트레이터 (메인 Claude)]
              ├→ Task(에이전트A: 설계) → 결과A
              ├→ Task(에이전트B: 구현) → 결과B
              └→ Task(에이전트C: 검증) → 결과C
                                ↓
                          종합 → 최종 결과
```

### 메인 Claude(오케스트레이터)의 역할

```
✅ 계획 수립
✅ 작업 분배 (Task 호출)
✅ 결과 종합/판단
✅ 실패 시 재시도 결정
❌ 직접 코드 작성 (에이전트에게 위임)
```

### 왜 직접 코드를 안 쓰나?

- 메인 Claude의 컨텍스트 윈도우는 한정적
- 직접 코드를 쓰면 파일 내용으로 컨텍스트가 가득 참
- 에이전트에게 위임하면 각자 독립된 컨텍스트에서 작업 → 메인은 깨끗하게 유지
- = **더 많은 작업을 안정적으로 처리 가능**

---

## 플러그인의 역할

플러그인은 Claude Code에게 **"이런 에이전트들이 있고, 이런 상황에서 이렇게 써라"**고 알려주는 설정 묶음.

```
플러그인 = Skills    (자동 적용되는 지식/원칙)
         + Commands  (사용자가 호출하는 워크플로우)
         + Agents    (위임 가능한 전문가)
         + Hooks     (자동 트리거 이벤트)
```

### 4가지 컴포넌트 비교

| | Skill | Command | Agent | Hook |
|---|---|---|---|---|
| **누가 트리거?** | Claude가 자동 | 사용자가 `/명령` | Command/Skill이 Task로 | 이벤트 발생 시 자동 |
| **비유** | 참고서 | 버튼 | 직원 | 알람 |
| **예시** | "코드 작성 시 이 원칙 따라" | `/autopilot 로그인 만들어` | architect, implementer | "파일 저장 시 린트 실행" |
| **실행 주체** | 메인 Claude가 참조 | 메인 Claude가 실행 | 독립 인스턴스 | 외부 스크립트 |

---

## Autopilot 동작 흐름 예시

```
사용자: "/autopilot 로그인 페이지 만들어"
```

### Phase 1 — 계획 (메인 Claude가 직접 수행)

```
"로그인 페이지를 만들려면..."
→ API 연동 필요
→ 폼 컴포넌트 필요
→ 라우팅 설정 필요
```

### Phase 2 — 설계 (순차 위임, 설계가 먼저 끝나야 구현 가능)

```
Task(architect) → "로그인 페이지 구조 설계해줘"
               → 결과: 파일 목록, 컴포넌트 구조, API 스펙
```

### Phase 3 — 구현 (병렬 위임, 독립적인 작업은 동시에)

```
Task(implementer, "LoginForm 컴포넌트 만들어")  ─┐
Task(implementer, "useLogin 훅 만들어")          ├→ 동시 실행!
Task(implementer, "login API 함수 만들어")       ─┘
```

### Phase 4 — 검증 (순차, 구현 끝난 후)

```
Task(verifier) → "빌드 돌려보고 결과 알려줘"
→ 실패 시 Phase 3로 돌아감
→ 성공 시 결과 보고
```

### 순차 vs 병렬 정리

전체 흐름은 **순차**. 병렬은 **같은 Phase 안에서** 독립적인 작업끼리만.

```
순차: 계획 ──→ 설계 ──→ 구현 ──→ 검증
                         │
                         └─ 이 안에서만 병렬
                            ├ 컴포넌트A
                            ├ 컴포넌트B
                            └ API 함수
```

---

## 위임 흐름 상세

```
Command(autopilot.md)가 로드됨
  → 메인 Claude가 지침을 읽음
  → 지침에 "architect 에이전트에게 위임하라"고 적혀있음
  → Task(subagent_type="plugin:architect") 호출
  → architect.md의 시스템 프롬프트가 적용된 새 Claude 생성
  → 새 Claude가 독립적으로 작업 수행
  → 결과를 메인 Claude에게 반환
  → 메인 Claude가 다음 단계 판단
```

---

## 오케스트레이션 패턴: 누가 지휘하나?

두 가지 패턴이 있다. 둘 다 가능하며, 상황에 따라 선택.

### 패턴 A: 메인 Claude가 지휘자

```
메인 Claude (= 지휘자)
  ├→ Task(설계 에이전트)
  ├→ Task(구현 에이전트)
  └→ Task(검증 에이전트)
```

### 패턴 B: 서브 에이전트가 지휘자 (OMC 방식)

```
메인 Claude
  └→ Task(오케스트레이터 에이전트)    ← 지휘자도 서브 에이전트
        ├→ Task(설계 에이전트)
        ├→ Task(구현 에이전트)
        └→ Task(검증 에이전트)
```

### 비교

| | 패턴 A (메인이 지휘) | 패턴 B (서브가 지휘) |
|---|---|---|
| **메인 컨텍스트** | 오케스트레이션 로직으로 소모됨 | 깨끗하게 유지 |
| **구조** | 단순 | 한 단계 더 중첩 |
| **적합한 상황** | 작업이 단순할 때 | 오케스트레이션 자체가 복잡할 때 |

### 왜 OMC는 패턴 B를 쓰나?

OMC의 오케스트레이션 로직은 "작업 분해 → 의존성 파악 → 병렬/순차 판단 → 실패 재시도 → 결과 종합"으로 꽤 복잡하다.
이걸 메인 Claude에서 하면 그것만으로 컨텍스트가 차니까, **전담 지휘자 에이전트**를 따로 둔다.

비유:
- **패턴 A** = 사장이 직접 직원들한테 업무 지시
- **패턴 B** = 사장이 팀장한테 위임, 팀장이 팀원들 관리

---

## 이해 체크

- [ ] Task 도구 = 새 Claude 인스턴스를 띄우는 것임을 안다
- [ ] 순차(Phase 간)와 병렬(Phase 내 독립 작업)의 차이를 안다
- [ ] 오케스트레이터가 직접 코드를 안 쓰는 이유를 안다 (컨텍스트 보존)
- [ ] Skill/Command/Agent/Hook 4가지의 트리거 차이를 구분할 수 있다

---

> 다음: [Level 2 — 플러그인 컴포넌트 상세](./level-2-components.md)
